/**
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

// Byte per audio sample. (32 bit float)
const BYTES_PER_SAMPLE = Float32Array.BYTES_PER_ELEMENT

// Basic byte unit of WASM heap. (16 bit = 2 bytes)
const BYTES_PER_UNIT = Uint16Array.BYTES_PER_ELEMENT

// The max audio channel on Chrome is 32.
const MAX_CHANNEL_COUNT = 32

// WebAudio's render quantum size.
const RENDER_QUANTUM_FRAMES = 128

const OPERATION_NONE = 0
const OPERATION_MULTIPLY = 1
const OPERATION_DIVIDE = 2

/**
 * A WASM HEAP wrapper for AudioBuffer class. This breaks down the AudioBuffer
 * into an Array of Float32Array for the convinient WASM opearion.
 *
 * @class
 * @dependency Module A WASM module generated by the emscripten glue code.
 */
class FreeQueue {
    /**
     * @constructor
     * @param  {object} wasmModule WASM module generated by Emscripten.
     * @param  {number} length Buffer frame length.
     * @param  {number} channelCount Number of channels.
     * @param  {number} channelDataLength wasm channel data Buffer frame length.
     * @param  {number} channelDataCount wasm Number of channels.
     * @param  {number=} maxChannelCount Maximum number of channels.
     */
    constructor(
        wasmModule,
        length,
        channelCount,
        channelDataLength,
        channelDataCount,
        maxChannelCount,
    ) {
        // HeapAudioBuffer initialization
        // The |channelCount| must be greater than 0, and less than or equal to
        // the maximum channel count.
        this._isInitialized = false
        this._module = wasmModule
        this._length = length
        this._channelDataLength = channelDataLength ? channelDataLength : length
        this._channelDataCount = channelDataCount ? channelDataCount : channelCount
        this._maxChannelCount = maxChannelCount
            ? Math.min(maxChannelCount, MAX_CHANNEL_COUNT)
            : channelCount
        this._channelCount = channelCount
        this._allocateHeap()
        this._isInitialized = true

        // RingBuffer initialization
        this._readIndex = 0
        this._writeIndex = 0
        this._framesAvailable = 0
        this._channelDataLocal = []
        for (let i = 0; i < this._channelCount; ++i) {
            this._channelDataLocal[i] = new Float32Array(length)
        }
    }

    /**
     * Allocates memory in the WASM heap and set up Float32Array views for the
     * channel data.
     *
     * @private
     */
    _allocateHeap() {
        const channelByteSize = this._channelDataLength * BYTES_PER_SAMPLE
        const dataByteSize = this._channelDataCount * channelByteSize
        this._dataPtr = this._module._malloc(dataByteSize)
        this._channelData = []
        for (let i = 0; i < this._channelDataCount; ++i) {
            const startByteOffset = this._dataPtr + i * channelByteSize
            const endByteOffset = startByteOffset + channelByteSize
            // Get the actual array index by dividing the byte offset by 2 bytes.
            this._channelData[i] = this._module.HEAPF32.subarray(
                startByteOffset >> BYTES_PER_UNIT,
                endByteOffset >> BYTES_PER_UNIT,
            )
        }
    }

    /**
     * Adapt the current channel count to the new input buffer.
     *
     * @param  {number} newChannelCount The new channel count.
     */
    adaptChannel(newChannelCount) {
        if (newChannelCount < this._maxChannelCount) {
            this._channelCount = newChannelCount
        }
    }

    /**
     * Getter for the buffer length in frames.
     *
     * @return {?number} Buffer length in frames.
     */
    get length() {
        return this._isInitialized ? this._length : null
    }

    /**
     * Getter for the number of channels.
     *
     * @return {?number} Buffer length in frames.
     */
    get numberOfChannels() {
        return this._isInitialized ? this._channelCount : null
    }

    /**
     * Getter for the maxixmum number of channels allowed for the instance.
     *
     * @return {?number} Buffer length in frames.
     */
    get maxChannelCount() {
        return this._isInitialized ? this._maxChannelCount : null
    }

    /**
     * Returns a Float32Array object for a given channel index. If the channel
     * index is undefined, it returns the reference to the entire array of channel
     * data.
     *
     * @param  {number|undefined} channelIndex Channel index.
     * @return {?Array} a channel data array or an
     * array of channel data.
     */
    getChannelData(channelIndex) {
        if (channelIndex >= this._channelDataCount) {
            return null
        }

        return typeof channelIndex === "undefined"
            ? this._channelData
            : this._channelData[channelIndex]
    }

    /**
     * Returns the base address of the allocated memory space in the WASM heap.
     *
     * @return {number} WASM Heap address.
     */
    getHeapAddress() {
        return this._dataPtr
    }

    /**
     * Returns the base address of the allocated memory space in the WASM heap.
     *
     * @return {number} WASM Heap address.
     */
    getPointer() {
        return this._dataPtr
    }

    /**
     * Frees the allocated memory space in the WASM heap.
     */
    free() {
        if (!this._isInitialized) {
            return
        }

        this._isInitialized = false
        this._module._free(this._dataPtr)
        this._channelData = null
    }

    /**
     * Getter for Available frames in buffer.
     *
     * @return {number} Available frames in buffer.
     */
    get framesAvailable() {
        return this._framesAvailable
    }

    /**
     * Push a sequence of Float32Arrays to buffer.
     *
     * @param  {array} arraySequence A sequence of Float32Arrays.
     * @param  {number} factor A factor to multiply or divide each data point by.
     * @param  {boolean} isMonoChannel Whether the data is mono channel.
     * @param  {number} operation The operation to perform: OPERATION_MULTIPLY, OPERATION_DIVIDE, or OPERATION_NONE.
     */
    push(arraySequence, factor = 1, isMonoChannel = false, operation = OPERATION_NONE) {
        // The channel count of arraySequence and the length of each channel must
        // match with this buffer obejct.

        if (arraySequence.length !== this._channelCount && !isMonoChannel) {
            throw new Error(
                `Channel count mismatch: expected ${this._channelCount}, but got ${arraySequence.length}.`,
            )
        }

        // Transfer data from the |arraySequence| storage to the internal buffer.
        const sourceLength = isMonoChannel ? arraySequence.length : arraySequence[0].length
        for (let i = 0; i < sourceLength; ++i) {
            if (isMonoChannel) {
                let fastData = arraySequence[i]
                if (operation === OPERATION_MULTIPLY) {
                    fastData *= factor
                } else if (operation === OPERATION_DIVIDE) {
                    fastData /= factor
                }

                for (let channel = 0; channel < this._channelCount; ++channel) {
                    this._channelDataLocal[channel][this._writeIndex] = fastData
                }
            } else {
                for (let channel = 0; channel < this._channelCount; ++channel) {
                    let value = arraySequence[channel][i]
                    if (operation === OPERATION_MULTIPLY) {
                        value *= factor
                    } else if (operation === OPERATION_DIVIDE) {
                        value /= factor
                    }
                    this._channelDataLocal[channel][this._writeIndex] = value
                }
            }

            this._writeIndex = (this._writeIndex + 1) % this._length
        }

        // For excessive frames, the buffer will be overwritten.
        this._framesAvailable += sourceLength
        if (this._framesAvailable > this._length) {
            this._framesAvailable = this._length
        }
    }

    /**
     * Pull data out of buffer and fill a given sequence of Float32Arrays.
     *
     * @param  {array} arraySequence An array of Float32Arrays.
     * @param  {number} factor A factor to multiply or divide each data point by.
     * @param  {boolean} isMonoChannel Whether the data is mono channel.
     * @param  {number} operation The operation to perform: OPERATION_MULTIPLY, OPERATION_DIVIDE, or OPERATION_NONE.
     */
    pull(arraySequence, factor = 1, isMonoChannel = false, operation = OPERATION_NONE) {
        // The channel count of arraySequence and the length of each channel must
        // match with this buffer obejct.

        if (arraySequence.length !== this._channelCount && !isMonoChannel) {
            throw new Error(
                `Channel count mismatch: expected ${this._channelCount}, but got ${arraySequence.length}.`,
            )
        }

        // If the FIFO is completely empty, do nothing.
        if (this._framesAvailable === 0) {
            return
        }

        const destinationLength = isMonoChannel ? arraySequence.length : arraySequence[0].length

        // Transfer data from the internal buffer to the |arraySequence| storage.
        for (let i = 0; i < destinationLength; ++i) {
            if (isMonoChannel) {
                let value = this._channelDataLocal[0][this._readIndex]
                if (operation === OPERATION_MULTIPLY) {
                    value *= factor
                } else if (operation === OPERATION_DIVIDE) {
                    value /= factor
                } else {
                }

                arraySequence[i] = value
            } else {
                for (let channel = 0; channel < this._channelCount; ++channel) {
                    let value = this._channelDataLocal[channel][this._readIndex]
                    if (operation === OPERATION_MULTIPLY) {
                        value *= factor
                    } else if (operation === OPERATION_DIVIDE) {
                        value /= factor
                    }
                    arraySequence[channel][i] = value
                }
            }

            this._readIndex = (this._readIndex + 1) % this._length
        }

        this._framesAvailable -= destinationLength
        if (this._framesAvailable < 0) {
            this._framesAvailable = 0
        }
    }

    clear() {
        this._readIndex = 0
        this._writeIndex = 0
        this._framesAvailable = 0
        for (let i = 0; i < this._channelCount; ++i) {
            this._channelDataLocal[i].fill(0)
        }
    }
} // class FreeQueue

export {
    MAX_CHANNEL_COUNT,
    RENDER_QUANTUM_FRAMES,
    FreeQueue,
    OPERATION_NONE,
    OPERATION_MULTIPLY,
    OPERATION_DIVIDE,
}
